#!/usr/bin/env node

/**
 * Flexible Scene Generator
 *
 * Generates a single scene into src/assets/scenes/{id}/ with:
 * - metadata.json
 * - {id}_100k.bin (or {id}_{points}.bin)
 * - {id}_50k.bin (fallback at ~50%)
 * Updates src/assets/scenes/registry.json (adds or replaces entry).
 *
 * Usage examples:
 *   npm run gen:scene -- --id=test_scene_01
 *   npm run gen:scene -- --id=campus_01 --points=150000 --type=mixed \
 *                      --name="Campus Quad" --desc="Campus outdoor scene"
 */

import { writeFileSync, readFileSync, mkdirSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const PROJECT_ROOT = join(__dirname, '..');

// ---------- CLI args ----------
const args = Object.fromEntries(
  process.argv
    .slice(2)
    .map((a) => a.replace(/^--/, ''))
    .map((kv) => {
      const [k, ...rest] = kv.split('=');
      return [k, rest.join('=') || 'true'];
    })
);

const sceneId = String(args.id || 'test_scene_01');
const points = Math.max(1000, Number(args.points || 100000));
const sceneType = String(args.type || 'mixed'); // vehicle | pedestrian | mixed
const name = String(args.name || `Synthetic ${sceneType} scene`);
const description = String(args.desc || 'Generated by tools/generate-scene.mjs');
const bounds = {
  min: [-50, -50, -2],
  max: [50, 50, 10],
};

function rand(min, max) {
  return Math.random() * (max - min) + min;
}

function uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

function generatePoints(count, b, type) {
  const pos = new Float32Array(count * 3);
  const [minX, minY, minZ] = b.min;
  const [maxX, maxY, maxZ] = b.max;
  for (let i = 0; i < count; i++) {
    const j = i * 3;
    const r = Math.random();
    if (r < 0.6) {
      pos[j] = rand(minX, maxX);
      pos[j + 1] = rand(minY, maxY);
      pos[j + 2] = rand(minZ, minZ + 0.4);
    } else if (r < 0.9) {
      pos[j] = rand(minX, maxX);
      pos[j + 1] = rand(minY, maxY);
      pos[j + 2] = rand(minZ, maxZ);
    } else {
      pos[j] = rand(minX, maxX);
      pos[j + 1] = rand(minY, maxY);
      pos[j + 2] = rand(minZ + 0.6, minZ + 3.0);
    }
  }
  return pos;
}

function generateDetections(type, b) {
  const dets = [];
  const [minX, minY, minZ] = b.min;
  const [maxX, maxY] = b.max;

  const counts =
    type === 'vehicle'
      ? { v: 15, p: 3, c: 1 }
      : type === 'pedestrian'
      ? { v: 2, p: 20, c: 3 }
      : { v: 8, p: 10, c: 4 };

  for (let i = 0; i < counts.v; i++)
    dets.push({
      id: uuid(),
      class: 'vehicle',
      center: [rand(minX + 5, maxX - 5), rand(minY + 5, maxY - 5), minZ + 0.8],
      dimensions: {
        width: rand(1.6, 2.1),
        length: rand(4.0, 5.2),
        height: rand(1.4, 1.9),
      },
      yaw: rand(-Math.PI, Math.PI),
      confidence: rand(0.85, 0.99),
    });

  for (let i = 0; i < counts.p; i++)
    dets.push({
      id: uuid(),
      class: 'pedestrian',
      center: [rand(minX + 2, maxX - 2), rand(minY + 2, maxY - 2), minZ + 0.9],
      dimensions: {
        width: rand(0.5, 0.7),
        length: rand(0.5, 0.7),
        height: rand(1.6, 1.85),
      },
      yaw: rand(-Math.PI, Math.PI),
      confidence: rand(0.80, 0.98),
    });

  for (let i = 0; i < counts.c; i++)
    dets.push({
      id: uuid(),
      class: 'cyclist',
      center: [rand(minX + 2, maxX - 2), rand(minY + 2, maxY - 2), minZ + 1.0],
      dimensions: {
        width: rand(0.6, 0.8),
        length: rand(1.6, 1.9),
        height: rand(1.6, 1.8),
      },
      yaw: rand(-Math.PI, Math.PI),
      confidence: rand(0.75, 0.96),
    });

  return dets;
}

function upsertRegistryEntry(id, name, description, pointCount) {
  const regPath = join(PROJECT_ROOT, 'src', 'assets', 'scenes', 'registry.json');
  if (!existsSync(regPath)) {
    const minimal = { version: '1.0.0', scenes: [] };
    writeFileSync(regPath, JSON.stringify(minimal, null, 2));
  }
  const reg = JSON.parse(readFileSync(regPath, 'utf-8'));
  const idx = reg.scenes.findIndex((s) => s.scene_id === id);
  const entry = {
    scene_id: id,
    name,
    description,
    complexity: 'medium',
    pointCount,
    hasFallback: true,
  };
  if (idx >= 0) reg.scenes[idx] = entry;
  else reg.scenes.push(entry);
  writeFileSync(regPath, JSON.stringify(reg, null, 2));
  console.log(`✓ Updated ${regPath}`);
}

(function main() {
  console.log(`\nGenerating scene: ${sceneId}`);
  const sceneDir = join(PROJECT_ROOT, 'src', 'assets', 'scenes', sceneId);
  mkdirSync(sceneDir, { recursive: true });

  // Detections and predictions
  const gt = generateDetections(sceneType, bounds);
  const predictions = {
    DSVT_Voxel: generateDetections(sceneType, bounds).map((d) => ({
      ...d,
      confidence: d.confidence * 0.95,
    })),
    AGILE3D_CP_Pillar_032: generateDetections(sceneType, bounds).map((d) => ({
      ...d,
      confidence: d.confidence * 0.97,
    })),
  };

  // Point clouds
  const stride = 3;
  const primaryCount = points;
  const fallbackCount = Math.max(1000, Math.floor(points / 2));
  const ptsPrimary = generatePoints(primaryCount, bounds, sceneType);
  const ptsFallback = generatePoints(fallbackCount, bounds, sceneType);

  const primaryName = `${sceneId}_${primaryCount >= 100000 ? '100k' : primaryCount}`;
  const fallbackName = `${sceneId}_${fallbackCount >= 100000 ? '100k' : fallbackCount}`;

  const primaryBin = join(sceneDir, `${primaryName}.bin`);
  const fallbackBin = join(sceneDir, `${fallbackName}.bin`);
  writeFileSync(primaryBin, Buffer.from(ptsPrimary.buffer));
  writeFileSync(fallbackBin, Buffer.from(ptsFallback.buffer));
  console.log(`✓ Wrote ${primaryBin}`);
  console.log(`✓ Wrote ${fallbackBin}`);

  // Metadata
  const metadata = {
    scene_id: sceneId,
    name,
    description,
    pointsBin: `assets/scenes/${sceneId}/${primaryName}.bin`,
    pointCount: primaryCount,
    pointStride: stride,
    bounds,
    ground_truth: gt,
    predictions,
    metadata: {
      vehicleCount: gt.filter((d) => d.class === 'vehicle').length,
      pedestrianCount: gt.filter((d) => d.class === 'pedestrian').length,
      cyclistCount: gt.filter((d) => d.class === 'cyclist').length,
      complexity: 'medium',
      optimalBranch: 'AGILE3D_CP_Pillar_032',
    },
  };

  const metadataPath = join(sceneDir, 'metadata.json');
  writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));
  console.log(`✓ Wrote ${metadataPath}`);

  // Update registry
  upsertRegistryEntry(sceneId, name, description, primaryCount);

  console.log('\nDone. Restart dev server or hard-reload the app to see the new scene.');
})();
